<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[css3手札]]></title>
      <url>http://blog.letzgo.ink/2017/02/26/css3%E6%89%8B%E6%9C%AD/</url>
      <content type="html"><![CDATA[<h3 id="CSS3新增常用"><a href="#CSS3新增常用" class="headerlink" title="CSS3新增常用"></a>CSS3新增常用</h3><pre><code class="css">box-shadow:X轴偏移量 Y轴偏移量阴影模糊半径 阴影扩展半径 阴影颜色;

border-color:上下左右
//示例:border-color: rgba(0,0,0,0.2) #fff;

border-radius: 0 0 0 4px;(上下左右);
</code></pre>
<a id="more"></a>
<h3 id="CSS3过渡"><a href="#CSS3过渡" class="headerlink" title="CSS3过渡"></a>CSS3过渡</h3><p><strong>属性:</strong><br>transition-property(CSS属性的名称)<br>transition-duration(过渡效果花费的时间(默认是是0))<br>transition-timing-function(过渡时间曲线)<br>transition-delay(过渡效果何时开始)  </p>
<p><strong>示例:</strong><br>transition:all 2s ease-out 0.5s</p>
<h3 id="animation-动画"><a href="#animation-动画" class="headerlink" title="animation(动画)"></a>animation(动画)</h3><p><strong>属性:</strong><br>animation-name(规定 @keyframes 动画的名称。 animation-duration(过渡效果花费的时间)<br>animation-timing-function(过渡时间曲线)<br>transition-delay(动画效果何时开始)<br>animation-iteration-count(规定动画播放的次数,infinite无限循环)<br>animation-direction(动画是否在下一周期逆向地播放)<br>animation-play-state(规定动画是否正在运行或暂停)  </p>
<p><strong>示例:</strong><br>animation: myfirst 5s linear 2s infinite alternate;</p>
<p><strong>注意:</strong><br>需要提前定义@keyframes</p>
<pre><code class="css">@keyframes myfirst
{
    0% {background: red;}
    25% {background: yellow;}
    50% {background: blue;}
    100% {background: green;}
}
</code></pre>
<h3 id="CSS3-2d过渡"><a href="#CSS3-2d过渡" class="headerlink" title="CSS3 2d过渡"></a>CSS3 2d过渡</h3><p><strong>属性:</strong><br>transform-origin: x-axis y-axis z-axis;(允许你改变被转换元素的位置/基线)<br>—–x-axis<br>定义视图被置于 X 轴的何处。可能的值：  </p>
<ul>
<li>left</li>
<li>center</li>
<li>right</li>
<li>length</li>
<li>%</li>
</ul>
<p>—–y-axis<br>定义视图被置于 Y 轴的何处。可能的值：  </p>
<ul>
<li>top</li>
<li>center</li>
<li>bottom</li>
<li>length</li>
<li>%</li>
</ul>
<p>—–z-axis<br>定义视图被置于 Z 轴的何处。可能的值：  </p>
<ul>
<li>length</li>
</ul>
<p><strong>方法</strong><br>translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。<br>scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。<br>rotate(angle) 定义 2D 旋转，在参数中规定角度。(单位 deg)<br>skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。</p>
<h3 id="CSS3-3d过渡"><a href="#CSS3-3d过渡" class="headerlink" title="CSS3 3d过渡"></a>CSS3 3d过渡</h3><h4 id="搭建3D场景（一级场景）"><a href="#搭建3D场景（一级场景）" class="headerlink" title="搭建3D场景（一级场景）"></a>搭建3D场景（一级场景）</h4><p>perspective: 800; 场景深度<br>perspective-origin: 50% 50%; 场景视角(默认)</p>
<h4 id="让transform识别3D场景（二级场景）"><a href="#让transform识别3D场景（二级场景）" class="headerlink" title="让transform识别3D场景（二级场景）"></a>让transform识别3D场景（二级场景）</h4><p>transform-style:perserve-3d;  </p>
<pre><code>-    flat 子元素将不保留其 3D 位置。  
-    preserve-3d 子元素将保留其 3D 位置。  
</code></pre><h4 id="属性（三级场景）"><a href="#属性（三级场景）" class="headerlink" title="属性（三级场景）"></a>属性（三级场景）</h4><ol>
<li>transform-origin (允许你改变被转换元素的位置/基线),比如以哪个为轴进行旋转  </li>
<li>backface-visibility 定义元素在不面对屏幕时是否可见。（visible：可见，hidden：不可见）  </li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>translate3d(x,y,z) 定义 3D 转化<br>rotate3d(x,y,z) 定义 3D 旋转。<br>scale3d(x,y,z) 定义 3D 缩放转换。<br>perspective(n) 定义 3D 转换元素的透视视图  </p>
<pre><code class="css">.cj {
        -webkit-perspective: 800;
        overflow: hidden
    }

    .dbox {
        height: 200px;
        width: 150px;
        margin-left: auto;
        margin-right: auto;
        -webkit-transform-style: preserve-3d;
    }

    .pg {
        height: 100%;
        line-height: 200px;
        width: 100%;
        color: #fff;
        background-color: #000;
        margin-left: auto;
        margin-right: auto;
        position: absolute;
        font-weight: bolder;
        font-size: 80px;
        text-align: center;
        transition: transform 2s;
        -webkit-transform-origin: bottom;
    }
    .pg2,.pg3{
        -webkit-transform: rotateX(90deg);
    }
    .pg1:hover {
        -webkit-transform: rotateX(-270deg);
    }
</code></pre>
<pre><code class="html">&lt;div class=&quot;cj&quot;&gt;
    &lt;div class=&quot;dbox&quot;&gt;
        &lt;div class=&quot;pg pg3&quot;&gt;3&lt;/div&gt;
        &lt;div class=&quot;pg pg2&quot;&gt;2&lt;/div&gt;
        &lt;div class=&quot;pg pg1&quot;&gt;1&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css3 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[细说ES6]]></title>
      <url>http://blog.letzgo.ink/2016/09/15/%CF%B8%CB%B5ES6/</url>
      <content type="html"><![CDATA[<h3 id="import、export、export-default"><a href="#import、export、export-default" class="headerlink" title="import、export、export default"></a>import、export、export default</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><ol>
<li>import 是 ES6的引入方式,在正式部署的生产环境中默认会去node_modules文件夹下查找,所以你查找当前目录下的模块的时候必须使用 ‘./‘</li>
<li><p>无对象导入:如果模块包含一些逻辑要执行，且不会导出任何对象，此类对象也可以被导入到另一模块中。如案例所示：</p>
<pre><code class="js">import &#39;./module1.js&#39;
</code></pre>
</li>
<li><p>导入默认对象</p>
<pre><code class="js">import d from &#39;./module1.js&#39;;
</code></pre>
</li>
<li><p>导入命名的对象，前提是模块的导出方式用的是export</p>
<pre><code class="js">import {Employee, getEmployee} from &#39;./module1.js&#39;;
</code></pre>
</li>
<li><p>导入所有对象</p>
<pre><code>import * as allFromModule1 from &#39;./module1.js&#39;;
</code></pre></li>
</ol>
<h4 id="export-和-export-default"><a href="#export-和-export-default" class="headerlink" title="export 和 export default"></a>export 和 export default</h4><ol>
<li>export与export default均可用于导出常量、函数、文件、模块等</li>
<li>一个文件或者模块中，export 可以有多个，引入方式为 import { a, b } from ‘demo1’</li>
<li>export default仅一个，引入方式为 import a from ‘demo2’</li>
</ol>
<blockquote>
<p>这里需要区分的是node中的引入方式也就是CommonJS规范：require 用来加载代码，而 exports 和 module.exports则用来导出代码。如果你想你的模块是一个特定的类型就用Module.exports。如果你想的模块是一个典型的“实例化对象”就用exports。请注意，这两种结果并不想同。前面已经提到module.exports是真正的接口，exports只不过是它的辅助工具。推荐使用exports导出，除非你打算从原来的“实例化对象”改变成一个类型。</p>
</blockquote>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><h4 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h4><p>Javascript语言的执行环境是”单线程”（single thread）。<br>所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。<br>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。<br>为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。<br>“同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。<br>“异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。  </p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery开发规范]]></title>
      <url>http://blog.letzgo.ink/2016/02/17/jquery%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h3 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h3><pre><code class="js">(function($){
    //Code goes here
})(jQuery);
</code></pre>
<a id="more"></a>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>jQuery提供了2个供用户扩展的‘基类’ - $.extend和$.fn.extend.</p>
<h4 id="extend-对jquery本身进行扩展开发"><a href="#extend-对jquery本身进行扩展开发" class="headerlink" title="$.extend 对jquery本身进行扩展开发"></a>$.extend 对jquery本身进行扩展开发</h4><p>第一种方式</p>
<pre><code class="javascript">$.extend({       
    foo: function() {       
        alert(&#39;This is a test. This is only a test.&#39;);       
    },       
    bar: function(param) {       
        alert(&#39;This function takes a parameter, which is &quot;&#39; + param +&#39;&quot;.&#39;);       
    }      
});  
//调用方法
$.foo();
$.bar(&#39;bar&#39;);
</code></pre>
<p>第二种方式</p>
<pre><code class="javascript">jQuery.foo = function() {    
    alert(&#39;This is a test. This is only a test.&#39;);   
};   
jQuery.bar = function(param) {    
    alert(&#39;This function takes a parameter, which is &quot;&#39; + param + &#39;&quot;.&#39;);   
};  
//调用方法
$.foo();
$.bar(&#39;bar&#39;);  
</code></pre>
<p>第三种方式（命名空间）</p>
<pre><code class="javascript">jQuery.myPlugin = {           
    foo:function() {           
        alert(&#39;This is a test. This is only a test.&#39;);           
    },           
    bar:function(param) {           
        alert(&#39;This function takes a parameter, which is &quot;&#39; + param + &#39;&quot;.&#39;);     
    }          
};   
// 采用命名空间的函数仍然是全局函数，调用时采用的方法：   
$.myPlugin.foo();          
$.myPlugin.bar(&#39;baz&#39;);  
</code></pre>
<h4 id="fn-extend-对象级别的扩展开发"><a href="#fn-extend-对象级别的扩展开发" class="headerlink" title="$.fn.extend 对象级别的扩展开发"></a>$.fn.extend 对象级别的扩展开发</h4><p>第一种方式</p>
<pre><code class="javascript">(function($){      
    $.fn.extend({      
        pluginName:function(opt,callback){      
            // Our plugin implementation code goes here.        
        }      
    })      
})(jQuery); 

//调用方法
$(&#39;#myDiv&#39;).pluginName(); 
</code></pre>
<p>第二种方式</p>
<pre><code class="javascript">(function($) {        
    $.fn.pluginName = function() {      
        // Our plugin implementation code goes here.      
    };      
})(jQuery);

//调用方法
$(&#39;#myDiv&#39;).pluginName(); 
</code></pre>
<blockquote>
<p>注意：接受options参数以控制插件的行为</p>
</blockquote>
<pre><code class="html">&lt;html&gt;
&lt;script language=&quot;javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function($) {
    //默认参数(放在插件外面, 避免每次调用插件都调用一次, 节省内存)
    var defaults = {
        color: &#39;红色&#39;
    };
    //扩展
    $.fn.extend({
        //插件名称
        height: function(options) {
            //覆盖默认参数
            var opts = $.extend(defaults, options);
            //主函数
            return this.each(function() {
                //激活事件
                var obj = $(this);
                obj.click(function() {
                    alert(opts.color);
                });
            });
        }
    });
})(jQuery);

$(function() {
    $(&quot;p&quot;).height({
        color: &#39;black&#39;
    });
});
&lt;/script&gt;

&lt;body&gt;
    &lt;p&gt;
        click here
    &lt;/p&gt;
&lt;/body&gt;
&lt;html&gt;
</code></pre>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>链式调用是jQuery的一大特色，一个通用的插件应该遵循jQuery风格，满足链式调用要求。实现链式调用的方式也很简单：</p>
<pre><code class="javascript">(function($){
     $.fn.changeStyle = function(colorStr){
         this.css(&quot;color&quot;,colorStr);        
         return this;
     }
}(jQuery));
</code></pre>
<p>然后使用的时候就可以链式调用其他方法了：</p>
<pre><code class="javascript">$(&quot;p&quot;).changeStyle(&quot;red&quot;).addClass(&quot;red-color&quot;);
</code></pre>
<p>实现链式调用的关键点就一行代码return this，插件中加了这行代码，那么在插件执行完之后，就会把当前的jQuery对象返回，然后就可以在插件方法后面继续调用其它jQuery方法。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> jquery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react 的ES5和ES6写法对比]]></title>
      <url>http://blog.letzgo.ink/2016/02/14/react-%E7%9A%84ES5%E5%92%8CES6%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<p>在javascript正式进入ES6时代后，react的语法也与时俱进的进行了大革新。这让很多初学者出现对ES6的困惑，今天在此整理了一些ES5和ES6的写法对照表，互相学习共勉。<br><a id="more"></a></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote>
<p>引用</p>
</blockquote>
<p>在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样：</p>
<pre><code class="javascript">var React = require(&quot;react-native&quot;);
var {
    Image,
    Text,
    PropTypes
} = React;  //引用不同的React Native组件
</code></pre>
<p>在ES6里，import写法更为标准</p>
<pre><code class="javascript">import React, {
    Image,
    Text,
    PropTypes
} from &#39;react-native&#39;;
</code></pre>
<p><div class="tip"><br>    注意在React Native里，import直到0.12+才能正常运作。<br></div></p>
<blockquote>
<p>导出单个类</p>
</blockquote>
<p>在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出</p>
<pre><code class="javascript">//ES5
var MyComponent = React.createClass({
    ...
});
module.exports = MyComponent;
</code></pre>
<p>在ES6里，通常用export default来实现相同的功能：</p>
<pre><code class="javascript">//ES6
export default class MyComponent extends React.Component{
    ...
}
</code></pre>
<p>引用的时候也类似：</p>
<pre><code class="javascript">//ES5
var MyComponent = require(&#39;./MyComponent.js&#39;);

//ES6
import MyComponent from &#39;./MyComponent.js&#39;;
</code></pre>
<h3 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h3><p>在ES5里，通常通过React.createClass来定义一个组件类，像这样：</p>
<pre><code class="javascript">//ES5
var Photo = React.createClass({
    render: function() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    },
});
</code></pre>
<p>在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样：</p>
<pre><code class="javascript">//ES6
class Photo extends React.Component {
    render() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    }
}
</code></pre>
<blockquote>
<p>给组件定义方法</p>
</blockquote>
<p>从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。</p>
<pre><code class="javascript">//ES5
var Photo = React.createClass({
    componentWillMount: function(){

    },
    render: function() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    },
});
//ES6
class Photo extends React.Component {
    componentWillMount() {

    }
    render() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    }
}
</code></pre>
<blockquote>
<p>定义组件的属性类型和默认属性</p>
</blockquote>
<p>在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现</p>
<pre><code class="javascript">//ES5
var Video = React.createClass({
    getDefaultProps: function() {
        return {
            autoPlay: false,
            maxLoops: 10,
        };
    },
    propTypes: {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    },
    render: function() {
        return (
            &lt;View /&gt;
        );
    },
});
</code></pre>
<p>在ES6里，可以统一使用static成员来实现</p>
<pre><code class="javascript">//ES6
class Video extends React.Component {
    static defaultProps = {
        autoPlay: false,
        maxLoops: 10,
    };  // 注意这里有分号
    static propTypes = {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    };  // 注意这里有分号
    render() {
        return (
            &lt;View /&gt;
        );
    } // 注意这里既没有分号也没有逗号
}
</code></pre>
<blockquote>
<p>初始化STATE</p>
</blockquote>
<p>ES5下情况类似，</p>
<pre><code class="javascript">//ES5
var Video = React.createClass({
    getInitialState: function() {
        return {
            loopsRemaining: this.props.maxLoops,
        };
    },
})
</code></pre>
<p>ES6下，有两种写法：</p>
<pre><code class="javascript">//ES6
class Video extends React.Component {
    state = {
        loopsRemaining: this.props.maxLoops,
    }
}
</code></pre>
<p>不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：</p>
<pre><code class="javascript">//ES6
class Video extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            loopsRemaining: this.props.maxLoops,
        };
    }
}
</code></pre>
<blockquote>
<p>把方法作为回调提供</p>
</blockquote>
<p>很多习惯于ES6的用户反而不理解在ES5下可以这么做：</p>
<pre><code class="javascript">//ES5
var PostInfo = React.createClass({
    handleOptionsButtonClick: function(e) {
        // Here, &#39;this&#39; refers to the component instance.
        this.setState({showOptionsModal: true});
    },
    render: function(){
        return (
            &lt;TouchableHighlight onPress={this.handleOptionsButtonClick}&gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;
            &lt;/TouchableHighlight&gt;
        )
    },
});
</code></pre>
<p>在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。<br>在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用</p>
<pre><code class="javascript">//ES6
class PostInfo extends React.Component
{
    handleOptionsButtonClick(e){
        this.setState({showOptionsModal: true});
    }
    render(){
        return (
            &lt;TouchableHighlight
                onPress={this.handleOptionsButtonClick.bind(this)}
                onPress={e=&gt;this.handleOptionsButtonClick(e)}
                &gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;
            &lt;/TouchableHighlight&gt;
        )
    },
}
</code></pre>
<p>箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</p>
<pre><code class="javascript">// 箭头函数的例子
()=&gt;1
v=&gt;v+1
(a,b)=&gt;a+b
()=&gt;{
    alert(&quot;foo&quot;);
}
e=&gt;{
    if (e == 0){
        return 0;
    }
    return 1000/e;
}
</code></pre>
<p>需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用</p>
<pre><code class="javascript">// 错误的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}
// 正确的做法
class PauseMenu extends React.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);
    }
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this._onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this._onAppPaused);
    }
    onAppPaused(event){
    }
}
</code></pre>
<p>从上面我们还学习到一种新的做法：</p>
<pre><code class="javascript">// 正确的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this.onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this.onAppPaused);
    }
    onAppPaused = (event) =&gt; {
        //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针
    }
}
</code></pre>
<h3 id="ES6带来的其它好处"><a href="#ES6带来的其它好处" class="headerlink" title="ES6带来的其它好处"></a>ES6带来的其它好处</h3><blockquote>
<p>解构&amp;属性延展</p>
</blockquote>
<p>结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签：</p>
<pre><code class="javascript">class AutoloadingPostsGrid extends React.Component {
    render() {
        var {
            className,
            ...others,  // contains all properties of this.props except for className
        } = this.props;
        return (
            &lt;div className={className}&gt;
                &lt;PostsGrid {...others} /&gt;
                &lt;button onClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
<p>下面这种写法，则是传递所有属性的同时，用覆盖新的className值：</p>
<pre><code class="javascript">&lt;div {...this.props} className=&quot;override&quot;&gt;
    …
&lt;/div&gt;
</code></pre>
<p>这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值</p>
<pre><code class="javascript">&lt;div className=&quot;base&quot; {...this.props}&gt;
    …
&lt;/div&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> ES5 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10分钟入门flex,轻松搭建flex框架]]></title>
      <url>http://blog.letzgo.ink/2016/01/12/30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E8%BD%BB%E6%9D%BE%E6%9E%B6%E6%9E%84flex%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h3 id="flex介绍"><a href="#flex介绍" class="headerlink" title="flex介绍"></a>flex介绍</h3><p>WEB布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。对于PC端的网页来讲，确实游刃有余。<br>进入移动互联网之后，人们开始发现类似让图片居中的东东很难完美实现。<br>于是2010年W3C提出的一种新的方案——flex，目前在移动端已经广泛运用。类似腾讯的小程序weui，阿里的antui，等等都已经将flex纳入自己的UI框架中。<br><a id="more"></a></p>
<div class="tip">注意啦，目前flex仅仅推荐用在移动端，pc端还是乖乖的用盒状模型吧！万恶的IE👿</div> 

<h3 id="flex布局语法"><a href="#flex布局语法" class="headerlink" title="flex布局语法"></a>flex布局语法</h3><p>好了，进入正题，下面的基础内容我摘录了<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">阮一峰的flex基础教程</a>。大家也可以去阮大大的博客去看，再后面我会讲到如何运用这些将你学到的这些flex封装成自己的flex布局框架。flex的布局语法，我会尽量用更容易懂的语言让大家理解。</p>
<h3 id="flex基本用法"><a href="#flex基本用法" class="headerlink" title="flex基本用法"></a>flex基本用法</h3><p>首先，任何一个HTML元素包括行内元素都可以设置为flex布局。</p>
<p><div class="tip">注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</div></p>
<pre><code class="css">.flex_box{
    display:flex;
    display:-webkit-flex /*webkit内核的浏览器需加前缀*/
}
.flex_nav{
    display:inline-flex；
    display:-webkit-inline-flex
}
</code></pre>
<h3 id="flex基本概念"><a href="#flex基本概念" class="headerlink" title="flex基本概念"></a>flex基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071004.png" alt><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071005.png"></p>
<pre><code class="css">.flex_box {
      flex-direction: row | row-reverse | column | column-reverse;
}
</code></pre>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071006.png" alt></p>
<pre><code class="css">.flex_box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
</code></pre>
<p>它可能取三个值。  </p>
<ul>
<li>（1）nowrap（默认）：不换行。<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071007.png"></li>
<li>（2）wrap：换行，第一行在上方。<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071008.jpg"></li>
<li>（3）wrap-reverse：换行，第一行在下方。<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071009.jpg"></li>
</ul>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<pre><code class="css">.flex_box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
</code></pre>
<p><img style="margin: 0" src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071010.png"><br>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<pre><code class="css">.flex_box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
</code></pre>
<p><img style="margin: 0" src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071011.png"><br>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<pre><code class="css">.flex_box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
</code></pre>
<p><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071012.png" alt><br>该属性可能取6个值。</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="flex项目属性"><a href="#flex项目属性" class="headerlink" title="flex项目属性"></a>flex项目属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<pre><code class="css">.flex_item{
      order: &lt;integer&gt;;
}
</code></pre>
<p><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071013.png" alt></p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<pre><code class="css">.flex_item{
  flex-grow: &lt;number&gt;; /* default 0 */
}
</code></pre>
<p><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071014.png" alt><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<pre><code class="css">.flex_item{
  flex-shrink: &lt;number&gt;; /* default 1 */
}
</code></pre>
<p><img src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071015.jpg" alt><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><img style="width: 70%;margin-bottom: 0" src="http://ohwq8bodu.bkt.clouddn.com/blog/8B32C0AF-A420-4C70-B4B3-9BFEBE91362B.png" alt><br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><img style="width: 70%;margin-bottom: 0" src="http://ohwq8bodu.bkt.clouddn.com/blog/14B7D9A8-FAF6-48AB-9C51-17048B02F51A.png"><br>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><img style="width: 70%;margin-bottom: 0" src="http://ohwq8bodu.bkt.clouddn.com/blog/B650431C-1862-4A55-A306-4BF68DE08B34.png"><br><img style="width: 50%;margin-top: 0" src="http://ohwq8bodu.bkt.clouddn.com/blog/bg2015071016.png"><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h3 id="搭建简单的flex框架"><a href="#搭建简单的flex框架" class="headerlink" title="搭建简单的flex框架"></a>搭建简单的flex框架</h3><p>接下来，你完全可以搭建自己的flex框架了。看示例代码。</p>
<blockquote>
<ul>
<li>首先，新建一个flex容器，也就是 .ws-flex 。<a href="#flex基本用法">&lt;查看flex基本用法&gt;</a> </li>
<li>然后设置 flex项目类 .ws-item ，默认设置其 水平轴和交叉轴居中。</li>
<li>其实大体框架已经搭好了，这里再继续对felx容器和组件加一点扩展类。</li>
<li>ws-flex-wrap：修饰flex容器的 ，自动换行，这个会经常用到。<a href="#flex-wrap">&lt;查看flex-wrap相关&gt;</a> </li>
<li>其次对flex项目进行细化，例如 <a href="#flex">ws-item-50</a> ，ws-item-10 等，类似bootstrap的栅栏系统。将这些flex项目分成若干个，方便我们日后布局。</li>
<li>最后还有对单个 flex 项目进行单独设置<a href="#justify-content">justify-content</a>和<a href="#align-items">align-items</a>属性。</li>
</ul>
</blockquote>
<pre><code class="css">.ws-flex {
    display: flex;
}
/* 自动换行 */
.ws-flex-wrap{
    flex-wrap: wrap;
    align-content: flex-start;
}
/* 默认交叉轴水平轴均居中 */
.ws-item {
    padding: 10px 0;
    display: flex;
    justify-content: center;
    align-items: center;
}
.ws-item-100{
    flex: 0 1 100%;
}
.ws-item-50{
    flex: 0 1 50%;
}
.ws-item-25{
    flex: 0 1 25%;
}
.ws-item-20{
    flex: 0 1 20%;
}
.ws-item-10{
    flex: 0 1 10%;
} 
.ws-item-right{
    justify-content: flex-end;
}
.ws-item-left{
    justify-content: flex-start;
}
.ws-item-top{
    align-items: flex-start;
}
.ws-item-bottom{
    align-items: flex-end;
}
/* 交叉轴占满整列空间 */
.ws-item-stretch{
    align-items: stretch;
}
/* 交叉轴首航文字基线对齐 */
.ws-item-baseline{
    align-items: baseline;
}
</code></pre>
<p>html代码,为了方便演示，给每个flex项目设置100px高度</p>
<pre><code class="html">&lt;div class=&quot;ws-flex ws-flex-wrap&quot;&gt;
    &lt;div class=&quot;ws-item ws-item-25&quot; style=&quot;height: 100px;background: #3273dc;color: #fff&quot;&gt;item25%&lt;/div&gt;
    &lt;div class=&quot;ws-item ws-item-25 ws-item-left&quot; style=&quot;height: 100px;background: #23d160;color: #fff&quot;&gt;item25%&lt;/div&gt;
    &lt;div class=&quot;ws-item ws-item-25&quot; style=&quot;height: 100px;background: #ffdd57;color: #fff&quot;&gt;item25%&lt;/div&gt;
    &lt;div class=&quot;ws-item ws-item-25 ws-item-bottom&quot; style=&quot;height: 100px;background: #ff3860;color: #fff&quot;&gt;item25%&lt;/div&gt;
    &lt;div class=&quot;ws-item ws-item-50&quot; style=&quot;height: 100px;background: #ff3860;color: #fff&quot;&gt;item50%&lt;/div&gt;
    &lt;div class=&quot;ws-item ws-item-10&quot; style=&quot;height: 100px;background: #3273dc;color: #fff&quot;&gt;item10%&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>看看最终的效果，是不是你想要的？<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/BE629B21-2F06-458F-A05B-DF3861D6BA1E.png" alt><br>接下来，在此基础上扩展属于你自己的UI框架吧!</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> flex </tag>
            
            <tag> UI框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[sublime编辑器前端开发使用]]></title>
      <url>http://blog.letzgo.ink/2015/12/29/sublime%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h4 id="前话"><a href="#前话" class="headerlink" title="前话"></a>前话</h4><p>一路走来，代码编辑器用了不下4个，从最早刚出道的时候的DW,到后来的WEBSTORM，这个编辑器用了很长时间，非常的强大，但是，但是，太耗内存了，于是想找个轻便的编辑器，上网搜罗，接着就是用了github开发的ATOM。当时看上纯粹就是‘哇！好好看的样子’。用着其实也还好，但是偶尔的时候会鬼畜。接下来说到正主——sublime。这个编辑其实老早之前用过一会，但是那会是小白，‘怎么用一个编辑器还这么麻烦？插件满天飞，配置也几乎都是英文的看不懂，后来就果断放弃了’。但是真正开始用的时候发现。确实很好用。功能强大至于也非常流畅。<br><a id="more"></a></p>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>接下来不废话了，讲讲sublime的配置。首先是core_setting,快捷键是’cmd+,’,弹出界面，设置你需要的基本配置。比如字体，间距，主题，等等。下面是我的配置。这里就略过了，英文不好的去找翻译。</p>
<pre><code class="javascript">{
    &quot;always_prompt_for_file_reload&quot;: false,
    &quot;always_show_minimap_viewport&quot;: false,
    &quot;animation_enabled&quot;: true,
    &quot;atomic_save&quot;: false,
    &quot;auto_close_tags&quot;: true,
    &quot;auto_complete&quot;: true,
    &quot;auto_complete_commit_on_tab&quot;: false,
    &quot;auto_complete_cycle&quot;: false,
    &quot;auto_complete_delay&quot;: 50,
    &quot;auto_complete_selector&quot;: &quot;meta.tag - punctuation.definition.tag.begin, source - comment - string.quoted.double.block - string.quoted.single.block - string.unquoted.heredoc&quot;,
    &quot;auto_complete_size_limit&quot;: 4194304,
    &quot;auto_complete_triggers&quot;:
    [
        {
            &quot;characters&quot;: &quot;&lt;&quot;,
            &quot;selector&quot;: &quot;text.html&quot;
        }
    ],
    &quot;auto_complete_with_fields&quot;: false,
    &quot;auto_find_in_selection&quot;: false,
    &quot;auto_indent&quot;: true,
    &quot;auto_match_enabled&quot;: true,
    &quot;binary_file_patterns&quot;:
    [
        &quot;*.jpg&quot;,
        &quot;*.jpeg&quot;,
        &quot;*.png&quot;,
        &quot;*.gif&quot;,
        &quot;*.ttf&quot;,
        &quot;*.tga&quot;,
        &quot;*.dds&quot;,
        &quot;*.ico&quot;,
        &quot;*.eot&quot;,
        &quot;*.pdf&quot;,
        &quot;*.swf&quot;,
        &quot;*.jar&quot;,
        &quot;*.zip&quot;
    ],
    &quot;bold_folder_labels&quot;: false,
    &quot;caret_extra_bottom&quot;: 0,
    &quot;caret_extra_top&quot;: 0,
    &quot;caret_extra_width&quot;: 0,
    &quot;caret_style&quot;: &quot;smooth&quot;,
    &quot;close_windows_when_empty&quot;: false,
    &quot;color_scheme&quot;: &quot;Packages/Babel/Monokai Phoenix.tmTheme&quot;,
    &quot;copy_with_empty_selection&quot;: true,
    &quot;create_window_at_startup&quot;: true,
    &quot;default_encoding&quot;: &quot;UTF-8&quot;,
    &quot;default_line_ending&quot;: &quot;system&quot;,
    &quot;detect_indentation&quot;: true,
    &quot;dictionary&quot;: &quot;Packages/Language - English/en_US.dic&quot;,
    &quot;drag_text&quot;: true,
    &quot;draw_centered&quot;: false,
    &quot;draw_indent_guides&quot;: true,
    &quot;draw_minimap_border&quot;: false,
    &quot;draw_white_space&quot;: &quot;selection&quot;,
    &quot;enable_hexadecimal_encoding&quot;: true,
    &quot;enable_tab_scrolling&quot;: true,
    &quot;ensure_newline_at_eof_on_save&quot;: false,
    &quot;fade_fold_buttons&quot;: true,
    &quot;fallback_encoding&quot;: &quot;Western (Windows 1252)&quot;,
    &quot;file_exclude_patterns&quot;:
    [
        &quot;*.pyc&quot;,
        &quot;*.pyo&quot;,
        &quot;*.exe&quot;,
        &quot;*.dll&quot;,
        &quot;*.obj&quot;,
        &quot;*.o&quot;,
        &quot;*.a&quot;,
        &quot;*.lib&quot;,
        &quot;*.so&quot;,
        &quot;*.dylib&quot;,
        &quot;*.ncb&quot;,
        &quot;*.sdf&quot;,
        &quot;*.suo&quot;,
        &quot;*.pdb&quot;,
        &quot;*.idb&quot;,
        &quot;.DS_Store&quot;,
        &quot;*.class&quot;,
        &quot;*.psd&quot;,
        &quot;*.db&quot;,
        &quot;*.sublime-workspace&quot;
    ],
    &quot;find_selected_text&quot;: true,
    &quot;fold_buttons&quot;: true,
    &quot;folder_exclude_patterns&quot;:
    [
        &quot;.svn&quot;,
        &quot;.git&quot;,
        &quot;.hg&quot;,
        &quot;CVS&quot;
    ],
    &quot;font_face&quot;: &quot;Fira Code&quot;,
    &quot;font_options&quot;:
    [
        &quot;no_round&quot;
    ],
    &quot;font_size&quot;: 15,
    &quot;gpu_window_buffer&quot;: &quot;auto&quot;,
    &quot;gutter&quot;: true,
    &quot;highlight_line&quot;: false,
    &quot;highlight_modified_tabs&quot;: false,
    &quot;hot_exit&quot;: true,
    &quot;ignored_packages&quot;:
    [
        &quot;Vintage&quot;
    ],
    &quot;indent_guide_options&quot;:
    [
        &quot;draw_normal&quot;
    ],
    &quot;indent_subsequent_lines&quot;: true,
    &quot;indent_to_bracket&quot;: false,
    &quot;index_exclude_patterns&quot;:
    [
        &quot;*.log&quot;
    ],
    &quot;index_files&quot;: true,
    &quot;index_workers&quot;: 0,
    &quot;line_numbers&quot;: true,
    &quot;line_padding_bottom&quot;: 5,
    &quot;line_padding_top&quot;: 5,
    &quot;margin&quot;: 4,
    &quot;match_brackets&quot;: true,
    &quot;match_brackets_angle&quot;: false,
    &quot;match_brackets_braces&quot;: true,
    &quot;match_brackets_content&quot;: true,
    &quot;match_brackets_square&quot;: true,
    &quot;match_selection&quot;: true,
    &quot;match_tags&quot;: true,
    &quot;move_to_limit_on_up_down&quot;: false,
    &quot;open_files_in_new_window&quot;: true,
    &quot;overlay_scroll_bars&quot;: &quot;system&quot;,
    &quot;preview_on_click&quot;: true,
    &quot;remember_full_screen&quot;: false,
    &quot;rulers&quot;:
    [
    ],
    &quot;save_on_focus_lost&quot;: false,
    &quot;scroll_past_end&quot;: true,
    &quot;scroll_speed&quot;: 3,
    &quot;shift_tab_unindent&quot;: false,
    &quot;show_definitions&quot;: true,
    &quot;show_encoding&quot;: true,
    &quot;show_errors_inline&quot;: true,
    &quot;show_full_path&quot;: true,
    &quot;show_line_endings&quot;: false,
    &quot;show_panel_on_build&quot;: true,
    &quot;show_tab_close_buttons&quot;: true,
    &quot;smart_indent&quot;: true,
    &quot;spell_check&quot;: false,
    &quot;spelling_selector&quot;: &quot;markup.raw, source string.quoted - punctuation - meta.preprocessor.c.include, source comment - source comment.block.preprocessor, -(source, constant, keyword, storage, support, variable, markup.underline.link, meta.tag)&quot;,
    &quot;tab_completion&quot;: true,
    &quot;tab_size&quot;: 4,
    &quot;theme&quot;: &quot;Seti.sublime-theme&quot;,
    &quot;translate_tabs_to_spaces&quot;: false,
    &quot;tree_animation_enabled&quot;: true,
    &quot;trim_automatic_white_space&quot;: true,
    &quot;trim_trailing_white_space_on_save&quot;: false,
    &quot;use_simple_full_screen&quot;: false,
    &quot;use_tab_stops&quot;: true,
    &quot;word_separators&quot;: &quot;./\\()\&quot;&#39;-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]{}`~?&quot;,
    &quot;word_wrap&quot;: &quot;auto&quot;,
    &quot;wrap_width&quot;: 0
}

</code></pre>
<h4 id="安装package-control"><a href="#安装package-control" class="headerlink" title="安装package control"></a>安装package control</h4><p>接下来就是最重要的插件了，首先你得装个packagecontrol包,sublime的包管理器。装完这个才能装插件。接下来走<a href="https://packagecontrol.io/" target="_blank" rel="noopener">packagecontrol官方</a>的教程。<br>方法1：菜单栏 View &gt; Show Console ，输入下面的代码回车，然后重启完成安装。</p>
<pre><code class="Python">import urllib.request,os,hashlib; h = &#39;df21e130d211cfc94d9b0905775a7c0f&#39; + &#39;1e3d39e33b79698005270310898eea76&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)
</code></pre>
<p>方法2：你也可以下载<a href="https://packagecontrol.io/Package%20Control.sublime-package" target="_blank" rel="noopener">packagecontrol</a>，然后cd到sublime的目录里（如何进入目录？见下图，打开后cd到上层目录找到packagecontrol文件夹，将你下载的文件放进去，重启）<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/C7BAD232-7F16-481A-9A01-12FF245B3FB9.png" alt="Alt text"></p>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>重启后，cmd + shift + p。输入 install package;正式安装你所需要的插件，这里数一下cmd + shift + p这个快捷键功能非常强大。在里面你可以搜索你任何需要的命令以及插件命令。当你记不住快捷键的时候，记得使用它。同时插播两个。list package是查看插件列表。remove package是删除插件以及主题。</p>
<h4 id="常用插件列表"><a href="#常用插件列表" class="headerlink" title="常用插件列表"></a>常用插件列表</h4><p><div class="tip"><br>    下面的所有插件，你都可以在<a href="https://packagecontrol.io/" target="_blank" rel="noopener">packagecontrol商店</a>搜到，并找到使用的方法。所以具体怎么用，我不再赘述。<br></div><br><strong>Alignment</strong> ：代码对齐插件，让你的代码更美丽；<br><strong>AutoFileName</strong> ：引入路径自动提示插件；<br><strong>Autoprefixer</strong>: css3必备，自动帮你增加css3兼容前缀；<br><strong>Babel</strong>: react写ES6的朋友必备；<br><strong>BracketHighlighter</strong>: 更强大的高亮插件；<br><strong>CSS3</strong> ：css3提示插件；<br><strong>DocBlockr</strong>: 注释插件；<br><strong>Emmet</strong>: 你懂得；<br><strong>HTML-CSS-JS Prettify</strong>:代码格式化插件，前端必备；<br><strong>HTML5</strong>:HTML5提示插件；<br><strong>Javascript &amp; NodeJs Snippets</strong>:快捷js插件；<br><strong>JavaScript Completions</strong>:js提示插件；<br><strong>Markdown Preview</strong> ：写MD必备；<br><strong>MarkdownEditing</strong> ：写MD必备；<br><strong>NodeJs</strong>:Node玩家必备；<br><strong>Sass</strong>:sass必备<br><strong>SideBarEnhancements</strong>: 栏目增强<br><strong>vue Syntax Highlight</strong>:vue高亮插件<br><strong>SublimeCodeIntel</strong>:代码提示插件  </p>
<blockquote>
<p>大部分插件都很容易安装，这里详细讲解下SublimeCodeIntel的安装方法</p>
</blockquote>
<ol>
<li>如果你想检测JS的语法和规范的话，需要提前安装jshint，css则一般安装csslint。如何安装，首先得安装node。然后命令行<pre><code>npm install jshint -g
npm install csslint -g
</code></pre></li>
<li>然后回到sublime,打开packagecontrol,依次安装 SublimeCodeIntel、SublimeLintel-jshint、SublimeLintel-csslint</li>
<li>安装完毕，按道理就可以检测相关语法了。</li>
<li>你可以定义自己的语法检测规则，JS的话在你的项目根目录放入 <strong>.jshintrc</strong> 文件，css的话在你的项目根目录放入 <strong>.csslintrc</strong> 文件。用sublime编辑里面填写你的语法检测配置项</li>
<li>下面贴出我的jshintrc配置。<pre><code class="json">{
 &quot;curly&quot;: true,
   &quot;eqeqeq&quot;: true,
   &quot;undef&quot;: true,
   &quot;forin&quot;: true,
   &quot;devel&quot;: true,
   &quot;jquery&quot;: true,
   &quot;strict&quot;: true
}
</code></pre>
curly 的意思是循环或者条件语句必须使用花括号包围<br>eqeqeq 是必须用全等于<br>undef 必须用定义到的变量<br>forin 这个选项要求所有 for in循环过滤对象的item。他在声明中允许for遍历一个对象所有属性的名称包括通过原型链继承来的属性。<br>devel 这个选项定义了全局变量,通常用于日志调试: console, alert等等<br>jquery 这个选项定义全局暴露的jQuery库。<br>strict 严格模式  </li>
<li><p>csslintrc配置。</p>
<pre><code class="json">{
 &quot;vendor-prefix&quot;               : true,
 &quot;duplicate-properties&quot;        : true,
 &quot;display-property-grouping&quot;   : true,
 &quot;empty-rules&quot;                 : true,

 &quot;adjoining-classes&quot;           : false,
 &quot;box-model&quot;                   : false,
 &quot;compatible-vendor-prefixes&quot;  : false,
 &quot;box-sizing&quot;                  : false,
 &quot;duplicate-background-images&quot; : false,
 &quot;floats&quot;                      : false,
 &quot;important&quot;                   : false,
 &quot;overqualified-elements&quot;      : false,
 &quot;rules-count&quot;                 : false,
 &quot;shorthand&quot;                   : false,
 &quot;zero-units&quot;                  : false
}
</code></pre>
</li>
</ol>
<h4 id="常用主题"><a href="#常用主题" class="headerlink" title="常用主题"></a>常用主题</h4><blockquote>
<p>应该是我喜欢的主题，每个人审美不一样。<a href="https://packagecontrol.io/" target="_blank" rel="noopener">packagecontrol商店</a>有很多，大家可以自己去找，安装主题的方法和插件是一样的。只是装完你要到<a href="#基本配置">基本配置</a>里面去设置一下“theme”和”color_scheme”,一个是sublime主题，一个是代码颜色主题，你可以自由搭配，这里我就推荐三个我现在用的Monokai spacegray,Seti_UI,Theme-Soda；</p>
</blockquote>
<h4 id="部分常用快捷键"><a href="#部分常用快捷键" class="headerlink" title="部分常用快捷键"></a>部分常用快捷键</h4><blockquote>
<p>我不想长篇大论把所有的列出来，就一些我常用的 。并且我改了一些快捷配置，让自己更顺手,下面是根据我的配置快捷键的用法。你可以自行去更改其他的键位或者增加更多的你喜好的快捷键</p>
</blockquote>
<p><img src="http://ohwq8bodu.bkt.clouddn.com/blog/24808929-ED29-4CE0-A394-F3F7803B4049.png" alt="Alt text"></p>
<pre><code class="javascript">[
    { &quot;keys&quot;: [&quot;super+alt+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: {&quot;panel&quot;: &quot;find&quot;, &quot;reverse&quot;: false} },
    { &quot;keys&quot;: [&quot;super+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: {&quot;panel&quot;: &quot;replace&quot;, &quot;reverse&quot;: false} },
    { &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: {&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;} },
    { &quot;keys&quot;: [&quot;f4&quot;], &quot;command&quot;: &quot;alignment&quot; },
    { &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;open_in_browser&quot; },
    { &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; }
]
</code></pre>
<ul>
<li>cmd + p : 在项目里搜索文件</li>
<li>cmd + F : 搜索并且替换</li>
<li>cmd + R : 搜索该文件内的方法</li>
<li>cmd + shift + p : 快捷键大全</li>
<li>cmd + D : 向下选择同样的代码，同时修改</li>
<li>F1 : 浏览器打开文件</li>
<li>F2 : 行跳转</li>
<li>F4 ：对齐代码</li>
<li>F5 ：格式化代码 这个需要到 HTML-CSS-JS Prettify插件 的配置文件里面去设置。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git-基本命令]]></title>
      <url>http://blog.letzgo.ink/2015/12/21/git-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h4 id="git-基本"><a href="#git-基本" class="headerlink" title="git 基本"></a>git 基本</h4><pre><code class="bash">git仓库初始化：git init

检出仓库：git clone

连接远程仓库：git remote add origin {server}

添加提交推送
git add * 添加所有文件
git add -f .gitignore 强制添加文件
git commit -m &quot;代码提交信息&quot;
git push origin master -u 推送

版本恢复： git reset —hard 版本号
</code></pre>
<a id="more"></a>
<h4 id="分支-branch-操作相关命令"><a href="#分支-branch-操作相关命令" class="headerlink" title="分支(branch)操作相关命令"></a>分支(branch)操作相关命令</h4><pre><code class="bash">查看本地分支：$ git branch

查看远程分支：$ git branch -r

切换分支：$ git checkout [name]

创建新分支并立即切换到新分支：$ git checkout -b [name]    例：git checkout -b dev

删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项

合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并

push分支到远程：$ git push origin [name]

删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]
</code></pre>
<h4 id="标签（tag）操作相关命令"><a href="#标签（tag）操作相关命令" class="headerlink" title="标签（tag）操作相关命令"></a>标签（tag）操作相关命令</h4><pre><code class="bash">打标签：    git tag v1.1.0

推送所有标签到远程：    git push origin --tags
</code></pre>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MAC系统制作U盘安装盘教程]]></title>
      <url>http://blog.letzgo.ink/2015/09/21/MAC%E7%B3%BB%E7%BB%9F%E5%88%B6%E4%BD%9CU%E7%9B%98%E5%AE%89%E8%A3%85%E7%9B%98%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>U盘 16G以上（想要快请用 USB3.0）<div class="tip"><br> U盘的卷标名不要用中文！任何英文都可以。<br></div></li>
<li>在 app store 中下载最新的 os X 系统，我这里下载的 OS X Yosemite.app，下面的内容我仍然用此为例<a id="more"></a>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3></li>
<li>插入U盘，打开“终端” 如下图<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/020140kxcpchbsoyw9cpyc.png" alt></li>
<li>在“终端”输入：sudo+空格（sudo的意思就是获取最高管理员权限)<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/789A6242-98B3-486A-A38C-F65111A56BE0.png" alt></li>
<li>找到 安装 OS X Yosemite.app 安装包，右键选择“显示包内容”  在Contents/Resources/文件夹下找到：<strong><em>createinstallmedia</em></strong> 看下图<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/020143uw6zcwln6nluu6pd.png" alt></li>
<li>将createinstallmedia文件拖入“终端”<br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/021455wdhhrrd4jk8bwnjw.png" alt></li>
<li>输入 –volume+空格，之后托入U盘图标至“终端”<br><img style="width:70%" src="http://ohwq8bodu.bkt.clouddn.com/blog/021513puxfdg6geqb2uvdi.png"></li>
<li>输入 –applicationpath+空格 ，之后将包托入“终端”<br><div class="tip" style="margin-bottom:0"><br> OS X Yosemite.app 安装文件需要去MAC APP STORE去下载，一般在应用文件夹下面，如果自已网上下载的就自行找到存储文件位置并托入<br></div><br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/022004nicxxya6lhykxfax.png" alt></li>
<li>最后输入 –nointeraction，按“return”<br><div class="tip" style="margin-bottom:0"><br>系统会显示图下图，并提示你输入电脑登录密码，如果没有密码直接按回车<br>如果看到 DONE 绿色框那里，就证明完成<br>PS:copying installer files to disk…. 需要一点时间出现这样的提示很等待直到完成显示 Done。一般不会出错。<br></div><br><img src="http://ohwq8bodu.bkt.clouddn.com/blog/022615imlnddxmnmxnmw37.png" alt></li>
</ol>
<h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><p>请重启并按Option键，选择安装盘安装即可以。</p>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mac </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10分钟用HEXO搭建个人博客]]></title>
      <url>http://blog.letzgo.ink/2015/09/15/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h4 id="1-安装NODE-安装GIT-申请GitHub（此处省略一万字，不知道的自行谷歌）"><a href="#1-安装NODE-安装GIT-申请GitHub（此处省略一万字，不知道的自行谷歌）" class="headerlink" title="1.安装NODE,安装GIT,申请GitHub（此处省略一万字，不知道的自行谷歌）"></a>1.安装NODE,安装GIT,申请GitHub（此处省略一万字，不知道的自行谷歌）</h4><p><div class="tip"><br>    这里需要注明的是，你在GitHub里新建项目的时候，你的项目名必须和你的用户名相同。完成后你可以通过 username.github.io 这个二级域名来访问你的博客。如果你想通过你自己的独立域名重定向到 博客。需要 在项目的 setting 中的 Custom domain 设置你的独立域名。<br>    <img src="http://ohwq8bodu.bkt.clouddn.com/blog/201612090305.png" alt="image"><br>    当然你自己的域名也必须设置 CNAME 访问，这里不做过多赘述。<br></div><br><a id="more"></a></p>
<h4 id="2-正式安装HEXO"><a href="#2-正式安装HEXO" class="headerlink" title="2.正式安装HEXO"></a>2.正式安装HEXO</h4><pre><code class="BASH">$ sudo npm install -g hexo
</code></pre>
<h4 id="3-cd到目录并且初始化"><a href="#3-cd到目录并且初始化" class="headerlink" title="3.cd到目录并且初始化"></a>3.cd到目录并且初始化</h4><pre><code class="BASH">hexo init
</code></pre>
<h4 id="4-本地启动-浏览器输入-http-localhost-4000-访问，这时候你就可以看到的blog程序的主页了"><a href="#4-本地启动-浏览器输入-http-localhost-4000-访问，这时候你就可以看到的blog程序的主页了" class="headerlink" title="4.本地启动(浏览器输入 http://localhost:4000 访问，这时候你就可以看到的blog程序的主页了)"></a>4.本地启动(浏览器输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 访问，这时候你就可以看到的blog程序的主页了)</h4><pre><code class="BASH">hexo server  
</code></pre>
<h4 id="5-新建文章"><a href="#5-新建文章" class="headerlink" title="5.新建文章"></a>5.新建文章</h4><pre><code class="BASH">hexo new &quot;postName&quot;
</code></pre>
<h4 id="6-生成静态文件至public目录"><a href="#6-生成静态文件至public目录" class="headerlink" title="6.生成静态文件至public目录"></a>6.生成静态文件至public目录</h4><pre><code class="BASH">hexo generate（hexo g  也可以）
</code></pre>
<h4 id="7-建立快捷的github部署"><a href="#7-建立快捷的github部署" class="headerlink" title="7.建立快捷的github部署"></a>7.建立快捷的github部署</h4><pre><code class="BASH">npm install hexo-deployer-git --save
</code></pre>
<h4 id="8-这时候找到根目录下-config-yml配置文件-将repository的路径引导到你的github的博客路径上"><a href="#8-这时候找到根目录下-config-yml配置文件-将repository的路径引导到你的github的博客路径上" class="headerlink" title="8.这时候找到根目录下_config.yml配置文件,将repository的路径引导到你的github的博客路径上"></a>8.这时候找到根目录下_config.yml配置文件,将repository的路径引导到你的github的博客路径上</h4><pre><code class="BASH">deploy:
    type: git
    repository: https://github.com/xxxxx/xxxxx.github.io.git
    branch: master
</code></pre>
<h4 id="9-一切大功告成，现在让我们完整执行一下。"><a href="#9-一切大功告成，现在让我们完整执行一下。" class="headerlink" title="9.一切大功告成，现在让我们完整执行一下。"></a>9.一切大功告成，现在让我们完整执行一下。</h4><pre><code class="BASH">hexo new &quot;postName&quot;     //新建文章
hexo generate           //生成静态文件
hexo deploy             //将静态文件git push 到你的博客程序
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux常用命令]]></title>
      <url>http://blog.letzgo.ink/2014/12/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><pre><code class="bash"># 移动某文件/文件夹到 某目录
mv phpmyadmin ../blog/  
# 删除某文件/文件/全部文件
rm -rf &lt;rootname&gt;/*
# 更改文件夹权限为 www 权限
chown -R www:www blog/
# 下载文件
wget &lt;href&gt;     
# 解压文件
tar zxvf  文件.tar.gz
</code></pre>
<a id="more"></a>
<h3 id="PHP操作命令"><a href="#PHP操作命令" class="headerlink" title="PHP操作命令"></a>PHP操作命令</h3><pre><code class="bash"># 查看mysql命令
/etc/init.d/mysql
# 查看nginx命令
/etc/init.d/nginx
# 查看php命令
/etc/init.d/php-fpm
# 重启nginx服务
/etc/init.d/nginx restart
</code></pre>
<h3 id="设置fish作默认shell"><a href="#设置fish作默认shell" class="headerlink" title="设置fish作默认shell"></a>设置fish作默认shell</h3><pre><code class="bash"># 查看fish 路径
type fish
# 设置fish作默认shell
chsh -s /usr/bin/fish
</code></pre>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js原理进阶]]></title>
      <url>http://blog.letzgo.ink/2014/08/02/js%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="封装，Prototype模式"><a href="#封装，Prototype模式" class="headerlink" title="封装，Prototype模式"></a>封装，Prototype模式</h4><p>Javascript规定，每一个构造函数都有一个<strong>prototype属性</strong>，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。<br><a id="more"></a></p>
<pre><code class="javascript">function Cat(name,color){
    this.name = name;
    this.color = color;
}
Cat.prototype.type = &quot;猫科动物&quot;;
Cat.prototype.eat = function(){alert(&quot;吃老鼠&quot;)};
</code></pre>
<h4 id="Prototype模式的验证方法"><a href="#Prototype模式的验证方法" class="headerlink" title="Prototype模式的验证方法"></a>Prototype模式的验证方法</h4><p>isPrototypeOf()方法用来判断某个proptotype对象和某个实例之间的关系。  </p>
<pre><code class="javascript">alert(Cat.prototype.isPrototypeOf(cat1)); //true
alert(Cat.prototype.isPrototypeOf(cat2)); //true
</code></pre>
<p>hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。  </p>
<pre><code class="javascript">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true
alert(cat1.hasOwnProperty(&quot;type&quot;)); // false
</code></pre>
<h4 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h4><blockquote>
<p>使用call或apply方法</p>
</blockquote>
<p>构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行  </p>
<pre><code class="javascript">function Animal() {　　　　
    this.species = &quot;动物&quot;;　　
}

function Cat(name, color) {　　　　
    Animal.apply(this);　
    this.name = name;　　　　
    this.color = color;　　
}　　
var cat1 = new Cat(&quot;大毛&quot;, &quot;黄色&quot;);　　
alert(cat1.species); // 动物
</code></pre>
<blockquote>
<p>prototype模式</p>
</blockquote>
<pre><code class="javascript">function Animal() {　　　　
    this.species = &quot;动物&quot;;　　
}

function Cat(name, color) {　　　　
    this.name = name;　　　　
    this.color = color;　　
}　　
Cat.prototype = new Animal();//将Cat的prototype属性指向Animal
Cat.prototype.constructor = Cat;//上一步操作的同时，也将Cat的constructor属性指向了Animal，为了维护正确的继承回朔链，我们再次用这个方法将Cat的构造函数找回来
var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);
alert(cat1.species); // 动物
</code></pre>
<blockquote>
<p>直接继承prototype</p>
</blockquote>
<pre><code class="javascript">function Animal(){ }//将Animal对象改写为空对象
Animal.prototype.species = &quot;动物&quot;;

function Cat(name, color) {　　　　
    this.name = name;　　　　
    this.color = color;　　
}　　
Cat.prototype = Animal.prototype;//将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承
Cat.prototype.constructor = Cat;
var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);
alert(cat1.species); // 动物
</code></pre>
<h4 id="非构造函数的继承"><a href="#非构造函数的继承" class="headerlink" title="非构造函数的继承"></a>非构造函数的继承</h4><blockquote>
<p>object()方法继承</p>
</blockquote>
<p>什么是”非构造函数”的继承？<br>比如，现在有一个对象，叫做”中国人”。  </p>
<pre><code class="javascript">var Chinese = {
    nation:&#39;中国&#39;
};
</code></pre>
<p>还有一个对象，叫做”医生”。  </p>
<pre><code class="javascript">var Doctor ={
    career:&#39;医生&#39;
}
</code></pre>
<p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？<br>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。  </p>
<pre><code class="javascript">var Chinese = {　　　　
    nation: &#39;中国&#39;　　
};
var Doctor = {　　　　
    career: &#39;医生&#39;　　
}

function object(o) {　　　　
    function F() {}　　　　
    F.prototype = o;　　　　
    return new F();
}

var Doctor = object(Chinese);　//使用的时候，第一步先在父对象的基础上，生成子对象： 　
Doctor.career = &#39;医生&#39;;//然后，再加上子对象本身的属性：
alert(Doctor.nation); //这时，子对象已经继承了父对象的属性了。
</code></pre>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。   </p>
<blockquote>
<p>拷贝继承</p>
</blockquote>
<pre><code class="javascript">function deepCopy(p, c) {　　　　
    var c = c || {};　　　　
    for (var i in p) {　　　　　　
        if (typeof p[i] === &#39;object&#39;) {　　　　　　　　
            c[i] = (p[i].constructor === Array) ? [] : {};　　　　　　　　
            deepCopy(p[i], c[i]);　　　　　　
        } else {　　　　　　　　　
            c[i] = p[i];　　　　　　
        }　　　　
    }　　　　
    return c;　　
}
</code></pre>
<p>使用的时候这样写：  </p>
<pre><code class="javascript">var Doctor = deepCopy(Chinese);
</code></pre>
<p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：  </p>
<pre><code class="javascript">Chinese.birthPlaces = [&#39;北京&#39;,&#39;上海&#39;,&#39;香港&#39;];
Doctor.birthPlaces.push(&#39;厦门&#39;);
</code></pre>
<p>这时，父对象就不会受到影响了。  </p>
<pre><code class="javascript">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
alert(Chinese.birthPlaces); //北京, 上海, 香港
</code></pre>
<h3 id="undefined与null的区别"><a href="#undefined与null的区别" class="headerlink" title="undefined与null的区别"></a>undefined与null的区别</h3><p>目前，null和undefined基本是同义的，只有一些细微的差别。<br>null表示”没有对象”，即该处不应该有值。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。  </p>
<pre><code class="javascript">
Object.getPrototypeOf(Object.prototype)// null
</code></pre>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。  </p>
<pre><code class="javascript">var i;
i // undefined
function f(x){console.log(x)}
f() // undefined
var  o = new Object();
o.p // undefined
var x = f();
x // undefined
</code></pre>
]]></content>
      
        <categories>
            
            <category> js基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS构造函数实例]]></title>
      <url>http://blog.letzgo.ink/2014/02/21/JS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h3 id="构造函数定义"><a href="#构造函数定义" class="headerlink" title="构造函数定义"></a>构造函数定义</h3><blockquote>
<p>JS的构造函数在设计之初一直有不少坑，很多人难以理解它的设计模式，这里将本人对JS的构造函数的理解分享给大家，如果有错误请指正。  </p>
<p><strong>构造函数的定义</strong>：对象自身所带的属性。  </p>
<p><strong>构造函数的作用</strong>：当对象被实例化后，构造函数会立即执行它所包含的任何代码</p>
</blockquote>
<a id="more"></a>
<h3 id="构造函数使用"><a href="#构造函数使用" class="headerlink" title="构造函数使用"></a>构造函数使用</h3><h4 id="1-对象方法"><a href="#1-对象方法" class="headerlink" title="1.对象方法"></a>1.对象方法</h4><blockquote>
<p>通过this调用</p>
</blockquote>
<pre><code class="JS">//对象构造函数  
   function Atest(name){  
       //公有属性,只能在对象实例化后调用  
       this.name = name;  
       //对象方法  
       this.hello = function(){  
           alert(this.name);  
       }  
   }
</code></pre>
<p>这里通过this来构造Atest的属性和方法，一般被称为公有属性，需要注意的是：公有属性,只能在对象实例化后被调用</p>
<h4 id="2-原型方法（prototype）"><a href="#2-原型方法（prototype）" class="headerlink" title="2.原型方法（prototype）"></a>2.原型方法（prototype）</h4><blockquote>
<p>通过prototype创建原型方法</p>
</blockquote>
<pre><code class="JS">    //原型方法  
    Atest.prototype.msg = function(){  
        alert(&quot;我的名字是：&quot;+this.name);//如果原型方法当作静态方法直接调用时，this.name无法被调用,必须实例化才行
    }  
    //原型属性，当作是类内部的属性使用【this.原型属性】，也可以当成公有静态属性使用【对象.prototype.原型属性】  
    Atest.prototype.sex = &quot;男&quot;;
</code></pre>
<div class="tip"><br>    尽量将方法定义为原型方法，原型方法避免了每次调用构造函数时对属性或方法的构造，节省空间,创建对象快.<br></div>

<div class="tip"><br>    ps:使用原型方法扩充的属性可以在类内部使用<br></div>

<pre><code class="JS">//对象构造函数  
function Atest(name){  
   //私有属性，只能在对象构造函数内部使用  
   var className = &quot;Atest&quot;;  
   //公有属性,在对象实例化后调用  
   this.name = name;  
   //对象方法  
   this.hello = function(){  
       alert(this.msg());//使用原型方法扩充的方法可以在类内部使用
       alert(this.sex);//使用原型方法扩充的属性可以在类内部使用  
   }  
}  
</code></pre>
<h4 id="3-类方法（静态方法直接调用）"><a href="#3-类方法（静态方法直接调用）" class="headerlink" title="3.类方法（静态方法直接调用）"></a>3.类方法（静态方法直接调用）</h4><pre><code class="JS">function Atest(name){  
    //私有属性，只能在对象构造函数内部使用  
    var className = &quot;Atest&quot;;  
    //对象方法  
    this.hello = function(){  
        alert(Atest.age);//静态属性调用时格式为[对象.静态属性]  
    }  
}  
//类方法 (实际是静态方法直接调用) 位置：Person类的外部 语法格式：类名称.方法名称 = function([参数...]){ 语句行; }  
Atest.Run = function(){  
    alert(&quot;我是类方法 Run&quot;);  
}  
//公有静态属性 在类的外部  
Atest.age = 20;//公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用
</code></pre>
<p><div class="tip"><br>    ps:静态方法只能用类来直接调用<br></div></p>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><pre><code class="JS">//对象构造函数
   function Atest(name){
       //私有属性，只能在对象构造函数内部使用
       var className = &quot;Atest&quot;;
       //公有属性,在对象实例化后调用
       this.name = name;
       //对象方法
       this.hello = function(){
           alert(this.name);
           alert(this.msg());//使用原型方法扩充的方法可以在类内部使用
           alert(this.sex);//使用原型方法扩充的属性可以在类内部使用
           alert(Atest.age);//静态属性调用时格式为[对象.静态属性]
       }
   }
   //类方法 (实际是静态方法直接调用) 位置：Person类的外部 语法格式：类名称.方法名称 = function([参数...]){ 语句行; }
   Atest.Run = function(){
       alert(&quot;我是类方法 Run&quot;);
   }


   //原型方法
   Atest.prototype.msg = function(){
       alert(&quot;我的名字是：&quot;+this.name);//如果原型方法当作静态方法直接调用时，this.name无法被调用
   }

   //公有静态属性 在类的外部
   Atest.age = 20;//公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用

   //原型属性，当作是类内部的属性使用【this.原型属性】，也可以当成公有静态属性使用【对象.prototype.原型属性】
   Atest.prototype.sex = &quot;男&quot;;

   Atest.Run(); //类方法也是静态方法，可以直接使用 【对象.静态方法()】
   Atest.prototype.msg();//原型方法当成静态方法使用时【对象.prototype.方法()】
   alert(Atest.prototype.sex);//原型属性当作静态属性使用时【对象.prototype.方法()】
   var a = new Atest(&quot;zhangsan&quot;);//对象方法和原型方法需要实例化对象后才可以使用
   a.hello();//对象方法必须实例化对象
   a.msg();//原型方法必须实例化对象
   alert(a.age);//错误，公有静态属性只能使用 【对象.属性】调用

   //ps:尽量将方法定义为原型方法，原型方法避免了每次调用构造函数时对属性或方法的构造，节省空间,创建对象快.
</code></pre>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js常用方法大全(不断更新...)]]></title>
      <url>http://blog.letzgo.ink/2013/01/04/js%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><ul>
<li><strong>arr.slice(begin,end)</strong><blockquote>
<p>截取数组,包左不包右</p>
</blockquote>
</li>
<li><strong>array.splice(start, deleteCount[, item1[, item2[, …]]])</strong>  <blockquote>
<p>用新元素替换旧元素，以此修改数组的内容</p>
<pre><code class="javascript">var removed = myFish.splice(2, 1, &quot;trumpet&quot;);
//从第2位开始删除1个元素,并在此处插入 &quot;trumpet&quot;
</code></pre>
<a id="more"></a></blockquote>
</li>
<li><strong>arr.reverse()</strong>  <blockquote>
<p>颠倒数组中元素的位置</p>
</blockquote>
</li>
<li><strong>arr.unshift(element1, …, elementN)</strong>  <blockquote>
<p>在数组的开头添加一个或者多个元素</p>
</blockquote>
</li>
<li><strong>arr.push(element1, …, elementN)</strong>  <blockquote>
<p>添加一个或多个元素到数组的末尾</p>
</blockquote>
</li>
<li><strong>arr.every(callback[, thisArg])</strong>  <blockquote>
<p>测试数组的所有元素是否都通过了指定函数的测试,返回true或者false (逻辑与的关系)</p>
</blockquote>
</li>
<li><strong>arr.some(callback[, thisArg])</strong>  <blockquote>
<p>测试数组中的某些元素是否通过了指定函数的测试,返回true或者false (逻辑或的关系)</p>
</blockquote>
</li>
<li><strong>str = arr.join([separator = ‘,’])</strong>  <blockquote>
<p>将数组中的所有元素连接成一个字符串</p>
</blockquote>
</li>
<li><strong>arr.indexOf(searchElement[, fromIndex = 0])</strong>  <blockquote>
<p>返回给定元素能找在数组中找到的第一个索引值，否则返回-1</p>
</blockquote>
</li>
<li><strong>array.concat(value1, value2, …, valueN)</strong>  <blockquote>
<p>将传入的数组或非数组值与原数组合并,组成一个新的数组并返回</p>
</blockquote>
</li>
<li><strong>arr.filter(callback[, thisArg])</strong>  <blockquote>
<p>使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组</p>
</blockquote>
</li>
<li><strong>array.map(callback[, thisArg])</strong>  <blockquote>
<p>返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组</p>
<pre><code class="javascript">var monthNames = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;];
  console.log(monthNames.map(function (i) {
  return i+1;
}));
</code></pre>
</blockquote>
</li>
<li><strong>arr.sort([compareFunction])</strong>  <blockquote>
<p>数组的元素做原地的排序，并返回这个数组</p>
<pre><code class="javascript">var numbers = [4, 2, 5, 1, 3];
  numbers.sort(function(a, b) {
  return a - b;
});
</code></pre>
</blockquote>
</li>
<li><strong>array.pop()</strong>  <blockquote>
<p>删除一个数组中的最后的一个元素，并且返回这个元素</p>
</blockquote>
</li>
<li><strong>arr.forEach</strong>  <blockquote>
<p>遍历数组</p>
<pre><code class="javascript">arr.forEach(function (i,index) {
  console.log(i+&#39;-----&#39;+index);
});
</code></pre>
</blockquote>
<h4 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h4></li>
<li><p><strong>apply</strong>  </p>
<blockquote>
<p>将对象引用到函数(对象替代函数中的this)当中,并以数组的方式传参</p>
<pre><code class="javascript">var person = {
  prop: &#39;person&#39;,
  say: function(say) {
      alert(this.prop + &#39;说&#39; + say)
  }
}
var child = {
  prop: &#39;child&#39;,
}
person.say.apply(child, [&#39;我是小孩&#39;])
</code></pre>
</blockquote>
</li>
<li><p><strong>call</strong>  </p>
<blockquote>
<p>将对象引用到函数(对象替代函数中的this)当中,并以数组的方式传参</p>
<pre><code class="javascript">var person = {
  prop: &#39;person&#39;,
  say: function(say) {
      alert(this.prop + &#39;说&#39; + say)
  }
}
var child = {
  prop: &#39;child&#39;,
}
person.say.call(child, &#39;我是小孩&#39;)
</code></pre>
</blockquote>
</li>
<li><p><strong>bind</strong></p>
<blockquote>
<p>bind(ES5新增):将对象替代函数中的this并且赋值给某一变量,返回一个函数</p>
<pre><code class="javascript">var obj = {
  name: &#39;A nice demo&#39;,
  fx: function() {
      alert(this.name);
  }
};
window.name = &#39;I am such a beautiful window!&#39;;
function runFx(f) {
  f();
}
function fx() {
  alert(this.name);
}
var fx2 = obj.fx.bind(obj);
runFx(obj.fx); // I am such a beautiful window!  
runFx(fx2); // A nice demo  
runFx(fx); // I am such a beautiful window!
</code></pre>
</blockquote>
</li>
</ul>
<h4 id="string方法"><a href="#string方法" class="headerlink" title="string方法"></a>string方法</h4><pre><code class="javascript">  //exec 从一个字符串匹配出正则中的词
  /abc/.exec(&#39;abcdef&#39;); //&quot;abc&quot; 

  //test 如果匹配成功返回true
  /abc/.test(&#39;abcdef&#39;); //true 

  //0 匹配出字符串第一次出现该条件的位置
  &quot;abcabcdef&quot;.search(/(abc)\1/); 

  //用正则替换该字符串,并且返回新的字符串
  String.prototype.replace &quot;aabbbbcc&quot;.replace(/b+?/,&quot;1&quot;) //aa1bbbcc 

  //匹配出字符串中所有符合的片段.返回一个片段数组
  String.prototype.match &quot;aabbbbccbbaa&quot;.match(/b+/g) //[&#39;bbbb&#39;,&#39;bb&#39;] 

  //用正则切割字符串,并返回切割后的片段数组
  String.prototype.split &quot;aabbbbccbbaa&quot;.split(/b+/) [&#39;aa&#39;,&#39;cc&#39;,&#39;aa&#39;] 

  //返回字符串中指定位置的字符
  str.charAt(index) 

  //返回字符串的大小写
  str.toUpperCase() str.toLowerCase() 

  //返回指定值在字符串对象中首次出现的位置。从 fromIndex 位置开始查找，如果不存在，则返回 -1。如果被查找的字符串是一个空字符串，此时返回 str.length
  str.indexOf(searchValue[, fromIndex]) 

  //返回字符串中从指定位置开始到指定长度的子字符串
  str.substr(start[, length]) 

  //返回字符串两个索引之间（或到字符串末尾）的子串
  str.substring(indexStart[, indexEnd]) 
</code></pre>
<h4 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h4><pre><code class="JavaScript">  //将一个 JSON 字符串解析成为一个 JavaScript 值
  JSON.parse(text[, reviver]) 
  //将任意的 JavaScript 值序列化成 JSON 字符串发送给后端
  JSON.stringify(value[, replacer [, space]]) 
</code></pre>
<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><pre><code class="JavaScript">  //用来判断某个对象是否含有指定的自身属性。
  Object.prototype.hasOwnProperty(prop) 

  //在一个对象上添加或修改一个或者多个自有属性，并返回该对象。
  Object.defineProperties(obj, props) 
  Object.defineProperties(foo,{
    x:{value:&#39;111&#39;,writable : false},
    y:{value:&#39;222&#39;,writable : false}
  });

  //返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
  Object.getOwnPropertyDescriptor(obj, prop) 

  //Object方法创建子对象
  Object.create(foo);

  //返回一个代表该对象的字符串,可以对此方法进行重写
  object.toString() 
  Dog.prototype.toString = function dogToString() {
    return &quot;Dog &quot; + this.name + &quot; is a &quot; + this.sex + &quot; &quot; + this.color + &quot; &quot; + this.breed;
  }
</code></pre>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
